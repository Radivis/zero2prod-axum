# Swagger UI Setup via Vite/React

## Overview

The Swagger UI is integrated into the React frontend instead of the Axum backend. This approach:

- ✅ Avoids Axum 0.8 compatibility issues with `utoipa-swagger-ui`
- ✅ Provides a seamless user experience (same navigation, theme, styling)
- ✅ Leverages the existing Vite proxy configuration
- ✅ Allows customization with React components

## Implementation

### 1. Dependencies

```bash
npm install swagger-ui-react
```

The package includes both the Swagger UI React component and the necessary CSS.

### 2. API Documentation Page

Created `frontend/src/pages/ApiDocs.tsx`:

```typescript
import SwaggerUI from 'swagger-ui-react';
import 'swagger-ui-react/swagger-ui.css';
import { Box, Typography, Paper } from '@mui/material';

export function ApiDocs() {
  return (
    <Box sx={{ p: 3 }}>
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h4" gutterBottom>
          API Documentation
        </Typography>
        <Typography variant="body1" color="text.secondary">
          Interactive documentation for the Zero2Prod API.
        </Typography>
      </Paper>
      
      <Paper sx={{ p: 2 }}>
        <SwaggerUI 
          url="/api/openapi.json"
          docExpansion="list"
          defaultModelsExpandDepth={1}
          displayRequestDuration={true}
        />
      </Paper>
    </Box>
  );
}
```

### 3. Routing

Added to `App.tsx`:

```typescript
import { ApiDocs } from './pages/ApiDocs'

// In Routes:
<Route path="/docs" element={<ApiDocs />} />
```

### 4. Navigation

Added "API Docs" link to `Layout.tsx`:

```typescript
<Button color="inherit" component={RouterLink} to="/docs">
  API Docs
</Button>
```

## How It Works

1. **Frontend requests** `/docs` → React Router serves `ApiDocs` component
2. **SwaggerUI component** requests `/api/openapi.json`
3. **Vite proxy** forwards request to backend at `http://localhost:8000/api/openapi.json`
4. **Backend returns** OpenAPI spec (generated by `utoipa`)
5. **SwaggerUI renders** interactive documentation

## Configuration Options

The `SwaggerUI` component accepts many props for customization:

```typescript
<SwaggerUI 
  url="/api/openapi.json"
  
  // UI options
  docExpansion="list"              // 'list' | 'full' | 'none'
  defaultModelsExpandDepth={1}      // How deep to expand schemas
  displayRequestDuration={true}     // Show request timing
  
  // Filtering
  filter={true}                     // Enable search/filter
  
  // Try it out
  tryItOutEnabled={true}            // Enable "Try it out" by default
  
  // Theme (can integrate with MUI theme)
  // Custom CSS can be applied via sx prop on wrapper
/>
```

## Benefits

### Developer Experience

- **Hot Module Replacement**: Changes to the OpenAPI spec are reflected immediately
- **Consistent Theme**: Swagger UI respects the app's light/dark mode
- **Single Dev Server**: No need to run separate documentation server

### User Experience

- **Integrated Navigation**: API docs accessible from main nav
- **No Auth Required**: Documentation is publicly accessible
- **Mobile Friendly**: Responsive design from MUI components

### Maintenance

- **Single Source of Truth**: OpenAPI spec is generated from Rust code
- **No Duplicate Configuration**: Frontend just consumes the backend spec
- **Easy Updates**: Add `#[utoipa::path]` annotations to routes, docs update automatically

## Alternative: Standalone Swagger UI

If you prefer to run Swagger UI as a separate service:

```bash
# Using Docker
docker run -p 8080:8080 \
  -e SWAGGER_JSON=/api/openapi.json \
  -e BASE_URL=/swagger \
  swaggerapi/swagger-ui

# Then access at http://localhost:8080/swagger
```

But the integrated approach is recommended for development.

## Adding More Endpoints to Documentation

To document additional endpoints, add `#[utoipa::path]` annotations to route handlers:

```rust
/// Subscribe to newsletter
#[utoipa::path(
    post,
    path = "/api/subscriptions",
    tag = "subscriptions",
    request_body = FormData,
    responses(
        (status = 200, description = "Successfully subscribed"),
        (status = 400, description = "Invalid form data"),
    )
)]
pub async fn subscribe(...) -> impl IntoResponse {
    // ...
}
```

Then add the path to the `ApiDoc` struct in `src/startup.rs`:

```rust
#[derive(OpenApi)]
#[openapi(
    info(...),
    paths(
        crate::routes::subscriptions::subscribe,  // Add this
        // ... other paths
    ),
    tags(...)
)]
struct ApiDoc;
```

The frontend will automatically pick up the changes!

## Troubleshooting

### Swagger UI not loading

1. Check that the backend is running and `/api/openapi.json` is accessible:
   ```bash
   curl http://localhost:8000/api/openapi.json
   ```

2. Check Vite proxy configuration in `vite.config.ts`:
   ```typescript
   proxy: {
     '/api': {
       target: 'http://localhost:8000',
       changeOrigin: true,
     }
   }
   ```

3. Check browser console for errors (CORS, network issues)

### Styling issues

The Swagger UI CSS might conflict with MUI. Wrap it in a Paper component with its own scope:

```typescript
<Paper sx={{ 
  p: 2,
  '& .swagger-ui': {
    // Custom overrides here
  }
}}>
  <SwaggerUI ... />
</Paper>
```

### Performance

For large APIs, limit the initial expansion:

```typescript
<SwaggerUI 
  docExpansion="none"
  defaultModelsExpandDepth={-1}  // Don't expand schemas
/>
```

## Production Deployment

In production, you can:

1. **Same approach**: Serve the frontend with Swagger UI included
2. **Separate docs site**: Build a docs-only version and deploy to docs subdomain
3. **Conditional rendering**: Only show `/docs` route in development

For now, the integrated approach works well for both development and production.
